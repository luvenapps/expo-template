name: iOS CI
on:
  workflow_call:
    inputs:
      env_prefix:
        description: Environment prefix (PROD or DEV)
        required: true
        type: string

permissions:
  contents: read

env:
  EXPO_USE_LOCAL_CLI: '1'
  METRO_CACHE_PATH: ${{ github.workspace }}/.metro-cache-ci
  IOS_DEVICE: 'iPhone 17'
  MAESTRO_VERSION: '2.0.6'
  FASTLANE_VERSION: '2.228.0'
  MAESTRO_DRIVER_STARTUP_TIMEOUT: 60000

jobs:
  ios-selfhosted:
    name: Build ‚Ä¢ E2E (iOS) - Self-hosted MacOS
    runs-on: [self-hosted, macos, arm64]
    timeout-minutes: 45
    concurrency:
      group: selfhosted-mobile-${{ github.repository }}
      cancel-in-progress: false

    steps:
      - name: Checkout
        uses: actions/checkout@v5

      - name: Setup Node 24
        uses: actions/setup-node@v6
        with:
          node-version-file: '.nvmrc'

      - name: Install deps
        run: npm ci

      - name: Map runtime variables and secrets
        shell: bash
        env:
          TURN_ON_FIREBASE: ${{ vars[format('{0}_TURN_ON_FIREBASE', inputs.env_prefix)] || vars.TURN_ON_FIREBASE || 'false' }}
          RETRIES_VALUE: ${{ vars[format('{0}_RETRIES', inputs.env_prefix)] || vars.RETRIES || '2' }}
          RETRY_DELAY_VALUE: ${{ vars[format('{0}_RETRY_DELAY', inputs.env_prefix)] || vars.RETRY_DELAY || '5' }}
          PROD_PUBLIC_SUPABASE_URL: ${{ vars.PROD_PUBLIC_SUPABASE_URL || '' }}
          DEV_PUBLIC_SUPABASE_URL: ${{ vars.DEV_PUBLIC_SUPABASE_URL || '' }}
          PROD_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.PROD_PUBLIC_SUPABASE_ANON_KEY || '' }}
          DEV_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.DEV_PUBLIC_SUPABASE_ANON_KEY || '' }}
          PROD_SUPABASE_ACCESS_TOKEN: ${{ secrets.PROD_SUPABASE_ACCESS_TOKEN || '' }}
          DEV_SUPABASE_ACCESS_TOKEN: ${{ secrets.DEV_SUPABASE_ACCESS_TOKEN || '' }}
        run: |
          echo "EXPO_PUBLIC_TURN_ON_FIREBASE=$TURN_ON_FIREBASE" >> "$GITHUB_ENV"
          echo "RETRIES=$RETRIES_VALUE" >> "$GITHUB_ENV"
          echo "RETRY_DELAY=$RETRY_DELAY_VALUE" >> "$GITHUB_ENV"

          if [ "${{ inputs.env_prefix }}" = "PROD" ]; then
            echo "EXPO_PUBLIC_SUPABASE_URL=$PROD_PUBLIC_SUPABASE_URL" >> "$GITHUB_ENV"
            echo "EXPO_PUBLIC_SUPABASE_ANON_KEY=$PROD_PUBLIC_SUPABASE_ANON_KEY" >> "$GITHUB_ENV"
            echo "SUPABASE_ACCESS_TOKEN=$PROD_SUPABASE_ACCESS_TOKEN" >> "$GITHUB_ENV"
          else
            echo "EXPO_PUBLIC_SUPABASE_URL=$DEV_PUBLIC_SUPABASE_URL" >> "$GITHUB_ENV"
            echo "EXPO_PUBLIC_SUPABASE_ANON_KEY=$DEV_PUBLIC_SUPABASE_ANON_KEY" >> "$GITHUB_ENV"
            echo "SUPABASE_ACCESS_TOKEN=$DEV_SUPABASE_ACCESS_TOKEN" >> "$GITHUB_ENV"
          fi

      - name: Check EAS CLI
        shell: bash
        run: |
          if ! command -v eas >/dev/null 2>&1; then
            echo "‚ùå EAS CLI not found on this runner."
            echo "Install it globally: npm i -g eas-cli@16.23.0"
            exit 1
          fi
          eas --version

      - name: Verify Expo/RN dependency alignment
        shell: bash
        run: |
          set -e
          npx expo --version || true
          node -e "console.log('react-native', require('react-native/package.json').version)" || true
          node -e "console.log('expo', require('expo/package.json').version)" || true
          # Strict: fail if mismatched so lockfile must be updated in a PR
          if ! npx expo install --check; then
            echo "‚ùå Expo dependency mismatch. Run 'npx expo install --fix' locally and commit the updated package-lock.json."
            exit 1
          fi

      - name: Make CI scripts executable
        run: chmod +x .github/scripts/*.sh

      - name: Setup Fastlane
        shell: bash
        run: .github/scripts/setup_fastlane.sh  "${{ env.FASTLANE_VERSION }}"

      - name: Setup Maestro
        shell: bash
        run: .github/scripts/setup_maestro.sh "${{ env.MAESTRO_VERSION }}"

      - name: Compute iOS build fingerprint
        id: ios_fp
        shell: bash
        env:
          GOOGLE_SERVICE_INFO_PLIST_B64: ${{ secrets.GOOGLE_SERVICE_INFO_PLIST_B64 }}
          GOOGLE_SERVICES_JSON_B64: ${{ secrets.GOOGLE_SERVICES_JSON_B64 }}
        run: ./.github/scripts/compute_fingerprint.sh ios >> "$GITHUB_OUTPUT"

      - name: Restore the tar.gz iOS app
        id: ios_cache
        uses: actions/cache/restore@v4
        with:
          path: ./*.tar.gz
          key: ${{ steps.ios_fp.outputs.key }}

      - name: Build e2erelease
        if: steps.ios_cache.outputs.cache-hit != 'true'
        shell: bash
        env:
          EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}
          GOOGLE_SERVICE_INFO_PLIST_B64: ${{ secrets.GOOGLE_SERVICE_INFO_PLIST_B64 }}
          GOOGLE_SERVICES_JSON_B64: ${{ secrets.GOOGLE_SERVICES_JSON_B64 }}
          EXPO_PUBLIC_FIREBASE_API_KEY: ${{ secrets.FIREBASE_API_KEY }}
          EXPO_PUBLIC_FIREBASE_APP_ID: ${{ secrets.FIREBASE_APP_ID }}
          EXPO_PUBLIC_FIREBASE_AUTH_DOMAIN: ${{ secrets.FIREBASE_AUTH_DOMAIN }}
          EXPO_PUBLIC_FIREBASE_MEASUREMENT_ID: ${{ secrets.FIREBASE_MEASUREMENT_ID }}
          EXPO_PUBLIC_FIREBASE_MESSAGING_SENDER_ID: ${{ secrets.FIREBASE_MESSAGING_SENDER_ID }}
          EXPO_PUBLIC_FIREBASE_PROJECT_ID: ${{ secrets.FIREBASE_PROJECT_ID }}
          EXPO_PUBLIC_FIREBASE_STORAGE_BUCKET: ${{ secrets.FIREBASE_STORAGE_BUCKET }}
          EXPO_PUBLIC_SUPABASE_URL: ${{ vars.PROD_PUBLIC_SUPABASE_URL }}
          EXPO_PUBLIC_SUPABASE_ANON_KEY: ${{ secrets.PROD_PUBLIC_SUPABASE_ANON_KEY }}
          SUPABASE_ACCESS_TOKEN: ${{ secrets.PROD_SUPABASE_ACCESS_TOKEN }}
        run: |
          set -euo pipefail
          ATTEMPTS="${RETRIES:-2}"
          DELAY="${RETRY_DELAY:-2}"
          i=1
          while [ "$i" -le "$ATTEMPTS" ]; do
            echo "üèóÔ∏è  iOS build attempt $i/$ATTEMPTS..."
            if eas build --platform ios --profile e2eRelease --local --non-interactive; then
              echo "‚úÖ Build succeeded on attempt $i"
              exit 0
            fi
            if [ "$i" -lt "$ATTEMPTS" ]; then
              echo "‚ùå Build attempt $i failed ‚Äî retrying in ${DELAY}s..."
              sleep "$DELAY"
            fi
            i=$((i+1))
          done
          echo "‚ùå Build failed after $ATTEMPTS attempts"
          exit 1

      - name: Save the tar.gz iOS app
        if: steps.ios_cache.outputs.cache-hit != 'true'
        uses: actions/cache/save@v4
        with:
          path: ./*.tar.gz
          key: ${{ steps.ios_fp.outputs.key }}

      - name: Locate .app artifact
        id: find_app
        shell: bash
        run: |
          set -euo pipefail
          ARTIFACT_TAR=$(ls -1t ./*.tar.gz 2>/dev/null | head -n1 || true)
          rm -rf extracted_app
          mkdir -p extracted_app
          if [ -n "$ARTIFACT_TAR" ]; then
            echo "üì¶ Extracting $ARTIFACT_TAR ..."
            tar -xzf "$ARTIFACT_TAR" -C extracted_app
          fi
          APP=$(find extracted_app -maxdepth 6 -type d -name "*.app" | head -n1 || true)
          echo "app=$APP" >> $GITHUB_OUTPUT
          [ -n "$APP" ] || (echo "No .app found after extracting $ARTIFACT_TAR"; ls -alh extracted_app || true; exit 1)

      - name: Run context snippet (engine + native project state)
        if: steps.ios_cache.outputs.cache-hit == 'true'
        shell: bash
        run: |
          echo "[run-snippet] pwd"
          pwd

          echo "[run-snippet] extracted app state"
          if [ -d extracted_app ]; then
            find extracted_app -maxdepth 4 -type d -name "*.app" -print || true
          else
            echo "extracted_app missing"
          fi

          echo "[run-snippet] expo public config (engine/runtime lines)"
          node -e "const { execSync } = require('node:child_process'); const config = JSON.parse(execSync('npx expo config --json', { encoding: 'utf8' })); const payload = { jsEngine: config.jsEngine ?? null, newArchEnabled: config.newArchEnabled ?? null, runtimeVersion: config.runtimeVersion ?? null, iosBundleIdentifier: config.ios?.bundleIdentifier ?? null }; console.log(JSON.stringify(payload, null, 2));"

      - name: Prepare iOS JS bundle for repack
        if: steps.ios_cache.outputs.cache-hit == 'true'
        shell: bash
        env:
          PLATFORM: ios
          METRO_CACHE_PATH: ${{ github.workspace }}/.metro-cache-ci
          GOOGLE_SERVICE_INFO_PLIST_B64: ${{ secrets.GOOGLE_SERVICE_INFO_PLIST_B64 }}
          GOOGLE_SERVICES_JSON_B64: ${{ secrets.GOOGLE_SERVICES_JSON_B64 }}
        run: |
          set -euo pipefail
          # Reset Watchman to prevent stale file system state from previous runs
          if command -v watchman >/dev/null 2>&1; then
            echo "üîÑ Resetting Watchman watches..."
            watchman watch-del-all || true
          fi
          echo "üì¶ Exporting release bundle before repack..."
          rm -rf ./dist
          npx expo export --platform "$PLATFORM" --output-dir ./dist --clear
          echo "üîç Verifying dist folder contents:"
          find ./dist -maxdepth 4 -print
          echo "expo-export" > dist/.bundle-source

      - name: Validate Hermes + bundle compatibility before repack
        if: steps.ios_cache.outputs.cache-hit == 'true'
        shell: bash
        run: |
          set -euo pipefail

          EXPO_CONFIG_JSON="$(npx expo config --json)"
          if [ -z "$EXPO_CONFIG_JSON" ]; then
            echo "‚ùå Failed to load Expo config JSON"
            exit 1
          fi

          EXPECTED_ENGINE="$(node -e "const cfg = JSON.parse(process.argv[1]); const engine = cfg.ios?.jsEngine ?? cfg.jsEngine ?? 'hermes'; process.stdout.write(String(engine).toLowerCase());" "$EXPO_CONFIG_JSON")"
          if [ -z "$EXPECTED_ENGINE" ]; then
            echo "‚ùå Could not determine expected iOS JS engine from Expo config"
            exit 1
          fi

          if [ ! -d dist ]; then
            echo "‚ùå dist folder is missing"
            exit 1
          fi

          if [ -z "$(find dist -mindepth 1 -maxdepth 1 -print -quit)" ]; then
            echo "‚ùå dist folder is empty"
            exit 1
          fi

          BUNDLE_PATH="$(find dist -type f \( -path "*/_expo/static/js/ios/*.js" -o -path "*/_expo/static/js/ios/*.hbc" \) | head -n1 || true)"
          if [ -z "$BUNDLE_PATH" ]; then
            echo "‚ùå iOS bundle file not found under dist/_expo/static/js/ios (.js or .hbc)"
            find dist -maxdepth 6 -type f | head -n 50 || true
            exit 1
          fi

          if [ ! -s "$BUNDLE_PATH" ]; then
            echo "‚ùå iOS bundle file is empty: $BUNDLE_PATH"
            exit 1
          fi

          BUNDLE_SIZE="$(wc -c < "$BUNDLE_PATH" | tr -d ' ')"
          HAS_HERMES_MARKER="no"
          if grep -a -q "Hermes" "$BUNDLE_PATH"; then
            HAS_HERMES_MARKER="yes"
          fi

          BUNDLE_SOURCE=""
          if [ -f dist/.bundle-source ]; then
            BUNDLE_SOURCE="$(cat dist/.bundle-source)"
          fi

          if [ "$EXPECTED_ENGINE" = "hermes" ] && [ "$HAS_HERMES_MARKER" != "yes" ] && [ "$BUNDLE_SOURCE" != "expo-export" ]; then
            echo "‚ùå Hermes expected but bundle has no Hermes marker and source is not expo-export"
            exit 1
          fi

          echo "[validation] expected engine: $EXPECTED_ENGINE"
          echo "[validation] bundle path: $BUNDLE_PATH"
          echo "[validation] bundle file size (bytes): $BUNDLE_SIZE"
          echo "[validation] hermes marker present: $HAS_HERMES_MARKER"
          echo "[validation] bundle source: ${BUNDLE_SOURCE:-unknown}"

      - name: Repack iOS app artifact with latest JS bundle
        if: steps.ios_cache.outputs.cache-hit == 'true'
        shell: bash
        env:
          PLATFORM: ios
          SOURCE_APP: ${{ steps.find_app.outputs.app }}
        run: |
          set -euo pipefail

          REPACKED_APP="repacked_output.app"
          rm -rf "$REPACKED_APP"
          npx @expo/repack-app --platform "$PLATFORM" --source-app "$SOURCE_APP" --output "$REPACKED_APP"

          if [ ! -d "$REPACKED_APP" ]; then
            echo "‚ùå Repacked .app not found at $REPACKED_APP"
            ls -la repacked_output* 2>/dev/null || true
            exit 1
          fi

          echo "Replacing $SOURCE_APP with repacked app from $REPACKED_APP..."
          rm -rf "$SOURCE_APP"
          mkdir -p "$(dirname "$SOURCE_APP")"
          mv "$REPACKED_APP" "$SOURCE_APP"

      - name: Boot simulator
        shell: bash
        run: .github/scripts/ios_boot_simulator.sh

      - name: Resolve app path for simulator install
        id: install_app
        shell: bash
        run: |
          set -euo pipefail
          APP="${{ steps.find_app.outputs.app }}"
          if [ ! -d "$APP" ]; then
            echo "‚ö†Ô∏è find_app output does not exist: $APP"
            APP="$(find extracted_app -maxdepth 6 -type d -name "*.app" | head -n1 || true)"
          fi

          if [ -z "$APP" ] || [ ! -d "$APP" ]; then
            echo "‚ùå Unable to resolve .app path for simulator install"
            find extracted_app -maxdepth 6 -print || true
            exit 1
          fi

          echo "Resolved app for install: $APP"
          echo "app=$APP" >> "$GITHUB_OUTPUT"

      - name: Install on simulator and warm up
        shell: bash
        timeout-minutes: 10
        run: .github/scripts/ios_install_app.sh "${{ steps.install_app.outputs.app }}"

      - name: Run E2E tests
        shell: bash
        run: .github/scripts/ios_run_e2e.sh

      - name: Upload Xcode build artifacts
        if: failure() && steps.ios_cache.outputs.cache-hit != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: xcode-build-artifacts-ios-selfhosted
          path: |
            ios/build/**/*.xcresult
            ios/build/**/*.log
            ~/Library/Developer/Xcode/DerivedData/**/Logs/Build/*.log
          if-no-files-found: ignore

      - name: Upload E2E artifacts on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-artifacts-ios-selfhosted
          path: |
            e2e-artifacts/**/*
            ios/build/**/*.log
          include-hidden-files: true

      - name: Clean self-hosted workspace
        if: always()
        shell: bash
        run: .github/scripts/clean_selfhosted_workspace.sh
